{"version":3,"sources":["../source/findPhoneNumbers.js"],"names":["findPhoneNumbers","searchPhoneNumbers","sort_out_arguments","VALID_PHONE_NUMBER","EXTN_PATTERNS_FOR_PARSING","WHITESPACE_IN_THE_BEGINNING_PATTERN","RegExp","WHITESPACE_IN_THE_END_PATTERN","VALID_PRECEDING_CHARACTER_PATTERN","arg_1","arg_2","arg_3","arg_4","text","options","metadata","search","PhoneNumberSearch","phones","hasNext","push","next","Symbol","iterator","done","value","state","regexp","matches","exec","number","startsAt","index","replace","length","result","parseCandidate","find","extended","phone","endsAt","last_match","Error","TypeError","defaultCountry"],"mappings":"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","file":"findPhoneNumbers.js","sourcesContent":["import parse from './parse'\nimport Metadata from './metadata'\n\nimport\n{\n\tPLUS_CHARS,\n\tVALID_PUNCTUATION,\n\tVALID_DIGITS,\n\t// OPENING_BRACKETS,\n\tWHITESPACE,\n\tcreate_extension_pattern\n}\nfrom './common'\n\nimport parsePreCandidate from './findNumbers/parsePreCandidate'\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate'\nimport isValidCandidate from './findNumbers/isValidCandidate'\n\n// Copy-pasted from `./parse.js`.\nconst VALID_PHONE_NUMBER =\n\t'[' + PLUS_CHARS + ']{0,1}' +\n\t'(?:' +\n\t\t'[' + VALID_PUNCTUATION + ']*' +\n\t\t'[' + VALID_DIGITS + ']' +\n\t'){3,}' +\n\t'[' +\n\t\tVALID_PUNCTUATION +\n\t\tVALID_DIGITS +\n\t']*'\n\nconst EXTN_PATTERNS_FOR_PARSING = create_extension_pattern('parsing')\n\nconst WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+')\nconst WHITESPACE_IN_THE_END_PATTERN = new RegExp('[' + WHITESPACE + ']+$')\n\n// // Regular expression for getting opening brackets for a valid number\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\n\nconst VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/\n\nexport default function findPhoneNumbers(arg_1, arg_2, arg_3, arg_4)\n{\n\tconst { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n\n\tconst search = new PhoneNumberSearch(text, options, metadata.metadata)\n\n\tconst phones = []\n\n\twhile (search.hasNext())\n\t{\n\t\tphones.push(search.next())\n\t}\n\n\treturn phones\n}\n\n/**\n * @return ES6 `for ... of` iterator.\n */\nexport function searchPhoneNumbers(arg_1, arg_2, arg_3, arg_4)\n{\n\tconst { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n\n\tconst search = new PhoneNumberSearch(text, options, metadata.metadata)\n\n\treturn  {\n\t\t[Symbol.iterator]() {\n\t\t\treturn {\n\t    \t\tnext: () => {\n\t    \t\t\tif (search.hasNext()) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\tvalue: search.next()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: true\n\t\t\t\t\t}\n\t    \t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Extracts a parseable phone number including any opening brackets, etc.\n * @param  {string} text - Input.\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\n */\nexport class PhoneNumberSearch\n{\n\t// Iteration tristate.\n\tstate = 'NOT_READY'\n\n\tconstructor(text, options = {}, metadata)\n\t{\n\t\tthis.text = text\n\t\tthis.options = options\n\t\tthis.metadata = metadata\n\n\t\tthis.regexp = new RegExp\n\t\t(\n\t\t\tVALID_PHONE_NUMBER +\n\t\t\t// Phone number extensions\n\t\t\t'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?',\n\t\t\t'ig'\n\t\t)\n\n\t\t// this.searching_from = 0\n\t}\n\n\tfind()\n\t{\n\t\tconst matches = this.regexp.exec(this.text)\n\n\t\tif (!matches) {\n\t\t\treturn\n\t\t}\n\n\t\tlet number   = matches[0]\n\t\tlet startsAt = matches.index\n\n\t\tnumber = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '')\n\t\tstartsAt += matches[0].length - number.length\n\t\tnumber = number.replace(WHITESPACE_IN_THE_END_PATTERN, '')\n\n\t\tnumber = parsePreCandidate(number)\n\n\t\tconst result = this.parseCandidate(number, startsAt)\n\n\t\tif (result) {\n\t\t\treturn result\n\t\t}\n\n\t\t// Tail recursion.\n\t\t// Try the next one if this one is not a valid phone number.\n\t\treturn this.find()\n\t}\n\n\tparseCandidate(number, startsAt)\n\t{\n\t\tif (!isValidPreCandidate(number, startsAt, this.text)) {\n\t\t\treturn\n\t\t}\n\n\t\t// Don't parse phone numbers which are non-phone numbers\n\t\t// due to being part of something else (e.g. a UUID).\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/213\n\t\t// Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\n\t\tif (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID'))\n\t\t{\n\t\t\treturn\n\t\t}\n\n\t\t// // Prepend any opening brackets left behind by the\n\t\t// // `PHONE_NUMBER_START_PATTERN` regexp.\n\t\t// const text_before_number = text.slice(this.searching_from, startsAt)\n\t\t// const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\n\t\t// if (full_number_starts_at >= 0)\n\t\t// {\n\t\t// \tnumber   = text_before_number.slice(full_number_starts_at) + number\n\t\t// \tstartsAt = full_number_starts_at\n\t\t// }\n\t\t//\n\t\t// this.searching_from = matches.lastIndex\n\n\t\tconst result = parse(number, this.options, this.metadata)\n\n\t\tif (!result.phone) {\n\t\t\treturn\n\t\t}\n\n\t\tresult.startsAt = startsAt\n\t\tresult.endsAt   = startsAt + number.length\n\n\t\treturn result\n\t}\n\n\thasNext()\n\t{\n\t\tif (this.state === 'NOT_READY')\n\t\t{\n\t\t\tthis.last_match = this.find()\n\n\t\t\tif (this.last_match)\n\t\t\t{\n\t\t\t\tthis.state = 'READY'\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.state = 'DONE'\n\t\t\t}\n\t\t}\n\n\t\treturn this.state === 'READY'\n\t}\n\n\tnext()\n\t{\n\t\t// Check the state and find the next match as a side-effect if necessary.\n\t\tif (!this.hasNext())\n\t\t{\n\t\t\tthrow new Error('No next element')\n\t\t}\n\n\t\t// Don't retain that memory any longer than necessary.\n\t\tconst result = this.last_match\n\t\tthis.last_match = null\n\t\tthis.state = 'NOT_READY'\n\t\treturn result\n\t}\n}\n\nexport function sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n{\n\tlet text\n\tlet options\n\tlet metadata\n\n\t// If the phone number is passed as a string.\n\t// `parse('88005553535', ...)`.\n\tif (typeof arg_1 === 'string')\n\t{\n\t\ttext = arg_1\n\t}\n\telse throw new TypeError('A text for parsing must be a string.')\n\n\t// If \"default country\" argument is being passed\n\t// then move it to `options`.\n\t// `findNumbers('88005553535', 'RU', [options], metadata)`.\n\tif (typeof arg_2 === 'string')\n\t{\n\t\tif (arg_4)\n\t\t{\n\t\t\toptions = { defaultCountry: arg_2, ...arg_3 }\n\t\t\tmetadata = arg_4\n\t\t}\n\t\telse\n\t\t{\n\t\t\toptions = { defaultCountry: arg_2 }\n\t\t\tmetadata = arg_3\n\t\t}\n\t}\n\t// No \"default country\" argument is being passed.\n\t// Only international phone numbers are passed.\n\t// `findNumbers('+78005553535', [options], metadata)`.\n\telse\n\t{\n\t\tif (arg_3)\n\t\t{\n\t\t\toptions  = arg_2\n\t\t\tmetadata = arg_3\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmetadata = arg_2\n\t\t}\n\t}\n\n\tif (!options)\n\t{\n\t\toptions = {}\n\t}\n\n\t// // Apply default options.\n\t// if (options)\n\t// {\n\t// \toptions = { ...default_options, ...options }\n\t// }\n\t// else\n\t// {\n\t// \toptions = default_options\n\t// }\n\n\treturn { text, options, metadata: new Metadata(metadata) }\n}"]}